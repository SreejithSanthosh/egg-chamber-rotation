% This script analyzes the basal surface cell movements
% in a drosophila egg chamber during rotation initiation 

clear; clc; close all;
warning('off', 'all')

dataFileNames = dir('./d/*removed.csv'); Nfiles = numel(dataFileNames); 
fac = 0.8; % How much filtering of the border cells fac = 1 (everything) fac = 0 (nothing)
tFilt = 4; % In the units of 15 sec (Time-scale of protrusions)
prctileCutOff = 0; % If there is a magnitude percentile of cell-movements above which to consider for analysis 
structData = struct;

for kk = 1:Nfiles

    structData(kk).fileName = dataFileNames(kk).name;
    structData(kk).isN1032 = contains(dataFileNames(kk).name,'N1032');
    structData(kk).isApical = contains(dataFileNames(kk).name,'pical');

    FileNamekk = strcat('./DataCombined/',dataFileNames(kk).name);
    T = readtable(FileNamekk);

    cellIdx = T.cell; cellPosX = T.centroid_row; cellPosY = T.centroid_col; cellTime = T.frame;
    tUnique = sort(unique(cellTime)); NtUnique = numel(tUnique);
    
    % Filter out the boundary cells   
    dataVel = struct; 
    
    for i = 1:NtUnique
        t_ct = tUnique(i); 
    
        logic_ct = cellTime == t_ct; cellIdx_ct = cellIdx(logic_ct); 
        x_ct = cellPosX(logic_ct); y_ct = cellPosY(logic_ct);
        
        % Filter inside vs outside
        yCOM_Emb = mean(y_ct); xCOM_Emb = mean(x_ct);
        yAxisDim = max(abs(y_ct-yCOM_Emb));
        xAxisDim = max(abs(x_ct-xCOM_Emb));
        
        logicFilt = ((x_ct-xCOM_Emb).^2)/(fac*xAxisDim)^2+((y_ct-yCOM_Emb).^2)/(fac*yAxisDim)^2<1;
    
        dataVel(i).x = x_ct(logicFilt); dataVel(i).y = y_ct(logicFilt); 
        dataVel(i).Idx = cellIdx_ct(logicFilt);
    end

    
    % Compute the net displacement between 
    % time-frames - given by (vx,vy) 

    vxScCells = []; vyScCells =[];

    for i = 1+tFilt:tFilt:NtUnique
        Idx_ct = dataVel(i).Idx; Idx_pt = dataVel(i-tFilt).Idx;
        
        C = intersect(Idx_ct,Idx_pt);
    
        xct = dataVel(i).x; xpt = dataVel(i-tFilt).x;
        yct = dataVel(i).y; ypt = dataVel(i-tFilt).y;
     
        t_ct = tUnique(i); t_pt = tUnique(i-tFilt); 
        logic_ct = cellTime == t_ct; xMask_ct = cellPosX(logic_ct); yMask_ct = cellPosY(logic_ct);
        logic_pt = cellTime == t_pt; xMask_pt = cellPosX(logic_pt); yMask_pt = cellPosY(logic_pt);
    
        vx_i = []; vy_i = [];
        for j = 1:numel(C)
            idx_j = C(j); log_ct = Idx_ct == idx_j; log_pt = Idx_pt == idx_j;
            xj_ct = xct(log_ct); xj_pt = xpt(log_pt);
            yj_ct = yct(log_ct); yj_pt = ypt(log_pt);
    
            vx_i = [vx_i,(xj_ct-xj_pt)]; vy_i = [vy_i,(yj_ct-yj_pt)];
        end 

        vxScCells = [vxScCells,vx_i]; vyScCells = [vyScCells,vy_i];
    end 
    
    % Compute the order parameters and solve it 
    polarOP = calculatepolarorder(vxScCells,vyScCells,prctileCutOff);
    structData(kk).polarOP = polarOP; 

end 


